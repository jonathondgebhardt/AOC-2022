// File auto-generated by StartNewDay

#include <print>

#include <gtest/gtest.h>

#include <Utilities.ipp>

namespace
{
    struct Solver
    {
        using Answer = std::optional<int64_t>;
        std::vector<std::string> mInput;

        static Solver Build(const bool useSample)
        {
            const auto inputFile = useSample ? "@DAY@_sample.txt" : "@DAY@.txt";
            return Solver{.mInput = util::ParseToContainer(util::GetInputFile(inputFile))};
        }
        
        Answer solvePartOne()
        {
            std::println(std::cerr, "Implement part one");
            return {};
        }

        Answer solvePartTwo()
        {
            std::println(std::cerr, "Implement part two");
            return {};
        }
    };
}

TEST(day_@DAY@, part_1)
{
    const auto answer = Solver::Build(false).solvePartOne();
    ASSERT_TRUE(answer.has_value());
    // EXPECT_EQ(*answer, INSERT_CORRECT_ANSWER);
    std::println("part one: {}", *answer);
}

TEST(day_@DAY@, part_2)
{
    const auto answer = Solver::Build(false).solvePartTwo();
    ASSERT_TRUE(answer.has_value());
    // EXPECT_EQ(*answer, INSERT_CORRECT_ANSWER);
    std::println("part two: {}", *answer);
}

TEST(day_@DAY@, sample_part_1)
{
    const auto answer = Solver::Build(true).solvePartOne();
    ASSERT_TRUE(answer.has_value());
    // EXPECT_EQ(*answer, PART_ONE_SAMPLE_ANSWER);
}

TEST(day_@DAY@, sample_part_2)
{
    const auto answer = Solver::Build(true).solvePartTwo();
    ASSERT_TRUE(answer.has_value());
    // EXPECT_EQ(*answer, PART_TWO_SAMPLE_ANSWER);
}
