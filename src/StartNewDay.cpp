#include <filesystem>
#include <format>
#include <fstream>
#include <iostream>
#include <optional>
#include <print>

#include <cxxopts.hpp>

#include "HttpsRequest.hpp"
#include "InputDirectoryConfig.hpp"
#include "Utilities.ipp"

std::string DAY;
std::string YEAR;
bool FORCE_OVERWRITE{false};
std::vector<std::string> CREATED_FILES;

bool DayIsValid()
{
    const auto day = util::StringTo<int>(DAY);
    return day >= 1 && day <= 31;
}

int GetCurrentYear()
{
    // https://stackoverflow.com/a/58153628
    const std::time_t t = std::time(nullptr);
    const std::tm* const pTInfo = std::localtime(&t);

    auto currentYear = 1900 + pTInfo->tm_year;

    // AoC starts December 1st. If it's not December yet, use the previous year.
    if(pTInfo->tm_mon < 11)
    {
        --currentYear;
    }

    return currentYear;
}

std::string GetCurrentYearString()
{
    return std::to_string(GetCurrentYear());
}

int GetCurrentDay()
{
    // https://stackoverflow.com/a/58153628
    const std::time_t t = std::time(nullptr);
    const std::tm* const pTInfo = std::localtime(&t);
    return pTInfo->tm_mday;
}

std::string GetCurrentDayString()
{
    return std::to_string(GetCurrentDay());
}

bool YearIsValid()
{
    const auto year = util::StringTo<int>(YEAR);
    return year >= 2015 && year <= GetCurrentYear();
}

bool TryCreateSolutionDirectory(const std::string& rootPath)
{
    if(std::filesystem::exists(rootPath) && !FORCE_OVERWRITE)
    {
        std::cout << "Solution directory already exists\n";
        return false;
    }

    std::filesystem::create_directory(rootPath);
    return std::filesystem::exists(rootPath);
}

bool CreateCMakeLists(const std::filesystem::path& x)
{
    const auto cmakeLists = x / "CMakeLists.txt";
    if(std::ofstream ofs{cmakeLists}; ofs.is_open())
    {
        ofs << std::format(R"(# File auto-generated by StartNewDay
cmake_minimum_required(VERSION 3.0...3.5)
project(day{} CXX)


add_executable(${{PROJECT_NAME}} {}.cpp
target_link_libraries(${{PROJECT_NAME}} GTest::gtest_main AOC)
include(GoogleTest)
gtest_discover_tests(${{PROJECT_NAME}}
)",
                           DAY, DAY);

#ifdef WIN32
        ofs << std::format(R"(
if(WIN32)
    set_target_properties(${{PROJECT_NAME}} PROPERTIES FOLDER "Solutions")
    target_sources(${{PROJECT_NAME}} PRIVATE ${{CMAKE_SOURCE_DIR}}/inputs/{}.txt ${{CMAKE_SOURCE_DIR}}/inputs/{}_sample.txt)
endif()
)",
                           DAY, DAY);
#endif

        CREATED_FILES.push_back(cmakeLists.string());

        return true;
    }

    return false;
}

// TODO: Use an in-file for this?
bool CreateSourceFiles(const std::filesystem::path& x)
{
    const auto solutionFile = DAY + ".cpp";
    const auto fullPath = x / solutionFile;

    if(std::ofstream ofs{fullPath}; ofs.is_open())
    {
        // TODO: Include gtest so user's don't have to?
        // ReSharper disable StringLiteralTypo
        ofs << std::vformat(R"(// File auto-generated by StartNewDay
#include <gtest/gtest.h>

#include "ACSolver.ipp"
#include "Utilities.ipp"

namespace
{
    struct Solver : public ACSolver
    {
        Answer solvePartOne() override
        {
            return ACSolver::solvePartOne();
        }

        Answer solvePartTwo() override
        {
            return ACSolver::solvePartTwo();
        }
    }

    Solver CreateSolver(bool useSample)
    {
        const auto inputFile = useSample ? \"{}_sample.txt\" : \"{}.txt\";
        Solver solver;
        solver.mInput = util::Parse(util::GetInputFile(inputFile));
        return solver;
    }
}

TEST(day_{}, part_1)
{
    const auto answer = CreateSolver(false).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    // EXPECT_EQ(*answer, INSERT_CORRECT_ANSWER);
    std::cout << \"part one: \" << *answer << std::endl;
}

TEST(day_{}, part_2)
{
    const auto answer = CreateSolver(false).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    // EXPECT_EQ(*answer, INSERT_CORRECT_ANSWER);
    std::cout << \"part two: \" << *answer << std::endl;
}

TEST(day_{}, sample_part_1)
{
    const auto answer = CreateSolver(true).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    // EXPECT_EQ(*answer, PART_ONE_SAMPLE_ANSWER);
}

TEST(day_{}, sample_part_2)
{
    const auto answer = CreateSolver(true).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    // EXPECT_EQ(*answer, PART_TWO_SAMPLE_ANSWER);
}
)",
                            std::make_format_args(DAY, DAY, DAY, DAY, DAY, DAY));
        // ReSharper restore StringLiteralTypo

        CREATED_FILES.push_back(fullPath.generic_string());

        return true;
    }

    return false;
}

// TODO: Make sure file doesn't already exist.
bool DownloadInput()
{
    HttpsRequest request;
    request.setUrl(std::format("https://adventofcode.com/{}/day/{}/input", YEAR, DAY));
    request.setContentType("text/plain");
    if(const auto content = request())
    {
        const auto fileName = config::GetInputFilePath() + "/" + DAY + ".txt";
        if(std::ofstream ofs{config::GetInputFilePath() + "/" + DAY + ".txt"}; ofs.is_open())
        {
            ofs << *content;

            CREATED_FILES.push_back(fileName);

            return true;
        }
    }

    return false;
}

// TODO: Make sure file doesn't already exist.
bool DownloadSampleInput()
{
    HttpsRequest request;
    request.setUrl(std::format("https://adventofcode.com/{}/day/{}", YEAR, DAY));
    request.setContentType("text/html");
    if(const auto content = request())
    {
        // Beginning of sample input starts with "<pre><code>" and ends with "</code></pre>"
        // Ex:
        // <pre><code>A Y
        // B X
        // C Z
        // </code></pre>
        const std::string startTags = "<pre><code>";
        const auto beginPos = content->find(startTags) + startTags.size();
        const auto endTags = "</code></pre>";
        const auto size = content->find(endTags) - beginPos;

        const auto fileName = config::GetInputFilePath() + "/" + DAY + "_sample.txt";
        if(std::ofstream ofs{fileName}; ofs.is_open())
        {
            ofs << content->substr(beginPos, size);

            CREATED_FILES.push_back(fileName);

            return true;
        }
    }

    return false;
}

int main(int argc, char** argv)
{
    cxxopts::Options options{
        "StartNewDay", "Create C++ stub code for new Advent of Code challenge and download input"};

    // TODO: Positional arguments are not showing up in help
    // clang-format off
    options.add_options()
        ("day", "The day number to use", cxxopts::value<std::string>()->default_value(GetCurrentDayString()))
        ("year", "The year to use", cxxopts::value<std::string>()->default_value(GetCurrentYearString()))
        ("f,force", "Force overwrite", cxxopts::value<bool>()->default_value("false"))
        ("h,help", "Shows this help message")
    ;
    // clang-format on

    options.parse_positional({"day", "year"});

    try
    {
        const auto result = options.parse(argc, argv);

        if(result.count("help"))
        {
            std::cout << options.help() << "\n";
            return EXIT_SUCCESS;
        }

        DAY = result["day"].as<std::string>();
        if(!DayIsValid())
        {
            std::println(std::cerr, "Error: '{}' must be between 1 and 31 inclusive", DAY);
            return EXIT_FAILURE;
        }

        YEAR = result["year"].as<std::string>();
        if(!YearIsValid())
        {
            std::println(std::cerr, "Error: '{}' must be between 2015 and current year inclusive",
                         YEAR);
            return EXIT_FAILURE;
        }

        FORCE_OVERWRITE = result["force"].as<bool>();

        const std::filesystem::path solutionsPath = config::GetSolutionsPath();
        if(!std::filesystem::exists(solutionsPath))
        {
            std::println(std::cerr, "Error: Could not find solutions path '{}'",
                         solutionsPath.string());
            return EXIT_FAILURE;
        }

        const auto newDayPath = solutionsPath / DAY;
        if(!TryCreateSolutionDirectory(newDayPath.generic_string()))
        {
            std::println(std::cerr, "Could not create new subdirectory {}", newDayPath.string());
            std::cout << options.help() << "\n";
            std::println(std::cerr);

            return EXIT_FAILURE;
        }

        if(FORCE_OVERWRITE)
        {
            std::println("Overwriting day {}...", DAY);
        }
        else
        {
            std::println("Starting new day {}...", DAY);
        }

        if(!CreateCMakeLists(newDayPath))
        {
            std::println(std::cerr, "Error: Could not create CMakeLists.txt for '{}'",
                         newDayPath.string());
            return EXIT_FAILURE;
        }

        if(!CreateSourceFiles(newDayPath))
        {
            std::println(std::cerr, "Error: Could not create source files for '{}'",
                         newDayPath.string());
            return EXIT_FAILURE;
        }

        if(!DownloadInput())
        {
            std::println(std::cerr, "Error: Could not download input");
            return EXIT_FAILURE;
        }

        if(!DownloadSampleInput())
        {
            // This is not a deal-breaker. Just grab it yourself ya bum.
            std::println(std::cerr, "Warning: Could not download sample input. Continuing...");
        }

        std::println("Files created:");
        std::ranges::copy(CREATED_FILES, std::ostream_iterator<std::string>(std::cout, "\n"));

        std::println();
        std::println("Re-run CMake to build the new day");

        return EXIT_SUCCESS;
    }
    catch(const cxxopts::exceptions::parsing& e)
    {
        std::println(std::cerr, "Error parsing option: {}", e.what());
        std::cout << options.help() << "\n";
    }
    catch(const cxxopts::exceptions::option_has_no_value& e)
    {
        std::println(std::cerr, "Error parsing required option: {}", e.what());
        std::cout << options.help() << "\n";
    }
    catch(const cxxopts::exceptions::specification& e)
    {
        std::println(std::cerr, "Error defining option specification: {}", e.what());
        std::println(std::cerr, "Please report this as a bug: "
                                "https://github.com/jonathondgebhardt/advent-of-code-cpp/issues");
    }
    catch(const cxxopts::exceptions::exception& e)
    {
        std::println(std::cerr, "Error: {}", e.what());
        std::cout << options.help() << "\n";
    }
    catch(const std::exception& e)
    {
        std::println(std::cerr, "Error: {}", e.what());
    }
    catch(...)
    {
        std::println(std::cerr, "Unknown error");
    }

    return EXIT_FAILURE;
}
