#include <InputDirectoryConfig.ipp>

#include <filesystem>
#include <fstream>
#include <iostream>
#include <optional>

void showUsage(const std::string& x)
{
    std::cout << "Usage: " << x << " NEW_DAY_SUBDIRECTORY_NAME [-f]\n";
    std::cout << "       NEW_DAY_SUBDIRECTORY_NAME Name of new day\n";
    std::cout << "       -f Force overwrite\n";
}

bool tryCreateSolutionDirectory(const std::string& rootPath, bool forceOverwrite)
{
    if(std::filesystem::exists(rootPath) && !forceOverwrite)
    {
        return false;
    }

    std::filesystem::create_directory(rootPath);
    return std::filesystem::exists(rootPath);
}

std::optional<std::pair<std::filesystem::path, std::filesystem::path>>
createSolutionPartDirectories(const std::filesystem::path& x)
{
    std::filesystem::path part1Path = x / "part1";
    std::filesystem::create_directory(part1Path);

    std::filesystem::path part2Path = x / "part2";
    std::filesystem::create_directory(part2Path);

    return std::make_pair(part1Path, part2Path);
}

bool createCMakeLists(const std::filesystem::path& x, bool isRoot)
{
    const auto cmakeLists = x / "CMakeLists.txt";
    std::ofstream ofs(cmakeLists);
    if(ofs.is_open())
    {
        ofs << "# File auto-generated by StartNewDay\n";

        ofs << "\n";

        if(isRoot)
        {
            ofs << "set(SOURCE_H\n";
            ofs << "    ${CMAKE_CURRENT_SOURCE_DIR}/Utilities.ipp\n";
            ofs << ")\n";

            ofs << "\n";

            ofs << "set(SOURCE\n";
            ofs << ")\n";

            ofs << "\n";

            ofs << "set(AOC_SOURCE_H\n";
            ofs << "    ${SOURCE_H}\n";
            ofs << "    ${AOC_SOURCE_H}\n";
            ofs << "    PARENT_SCOPE\n";
            ofs << ")\n";

            ofs << "\n";

            ofs << "set(AOC_SOURCE\n";
            ofs << "    ${SOURCE}\n";
            ofs << "    ${AOC_SOURCE}\n";
            ofs << "    PARENT_SCOPE\n";
            ofs << ")\n";

            ofs << "\n";

            ofs << "add_subdirectory(part1)\n";
            ofs << "add_subdirectory(part2)\n";
        }
        else
        {
            ofs << "cmake_minimum_required(VERSION 3.0)\n";

            ofs << "\n";

            const auto dayNumber = std::string(x.parent_path().filename());
            const auto partNumber = std::string(x.filename());
            ofs << "project(aoc_" << dayNumber << "_" << partNumber << " CXX)\n";

            ofs << "\n";

            ofs << "set(SOURCE_H\n";
            ofs << ")\n";

            ofs << "\n";

            ofs << "set(SOURCE\n";
            ofs << "    main.cpp\n";
            ofs << ")\n";

            ofs << "\n";

            ofs << "add_executable(${PROJECT_NAME} ${SOURCE_H} ${SOURCE})\n";

            ofs << "\n";

            ofs << "target_link_libraries(${PROJECT_NAME} AOC)\n";
        }

        return true;
    }

    return false;
}

bool createSourceFiles(const std::filesystem::path& x, bool isRoot)
{
    if(isRoot)
    {
        std::ofstream ofs(x / "Utilities.ipp");
        if(!ofs.is_open())
        {
            return false;
        }

        ofs << "#pragma once\n";

        ofs << "\n";

        ofs << "// File auto-generated by StartNewDay\n";

        ofs << "\n";

        ofs << "#include <Export.hpp>\n";
        ofs << "#include <Utilities.ipp>\n";

        ofs << "\n";

        const auto dayNumber = std::string(x.filename());
        ofs << "namespace util::" << dayNumber << "\n";
        ofs << "{\n";
        ofs << "}\n";

        return true;
    }
    else
    {
        std::ofstream ofs(x / "main.cpp");
        if(!ofs.is_open())
        {
            return false;
        }

        const auto dayNumber = std::string(x.parent_path().filename());

        ofs << "#include <" << dayNumber << "/Utilities.ipp>\n";

        ofs << "\n";

        ofs << "// File auto-generated by StartNewDay\n";

        ofs << "\n";

        ofs << "int main(int, char**)\n";
        ofs << "{\n";
        ofs << "  return EXIT_SUCCESS;\n";
        ofs << "}\n";

        return true;
    }
}

void showNewDayContents(const std::filesystem::path& x, size_t indent = 1)
{
    for(const auto& item : std::filesystem::directory_iterator(x))
    {
        for(size_t i = 0; i < indent; ++i)
        {
            std::cout << "\t";
        }

        std::cout << item << "\n";

        if(std::filesystem::is_directory(item))
        {
            showNewDayContents(item, ++indent);
            --indent;
        }
    }
}

int main(int argc, char* argv[])
{
    const auto applicationName = std::string(argv[0]);

    if(argc < 2)
    {
        showUsage(applicationName);
        return EXIT_FAILURE;
    }

    std::filesystem::path solutionsPath(config::GetSolutionsPath());
    if(!std::filesystem::exists(solutionsPath))
    {
        std::cerr << "Could not find solutions path " << solutionsPath << "\n";
        return EXIT_FAILURE;
    }

    constexpr size_t newDayIndex = 1;
    const auto newDay = std::string(argv[newDayIndex]);

    constexpr size_t forceOverwriteIndex = 2;
    auto forceOverwrite = false;

    if(argc == 3 && std::string(argv[forceOverwriteIndex]) == "-f")
    {
        forceOverwrite = true;
    }

    const auto newDayPath = solutionsPath / newDay;
    if(!tryCreateSolutionDirectory(newDayPath, forceOverwrite))
    {
        std::cerr << "Could not create new subdirectory " << newDayPath << "\n";
        std::cerr << "Check write permissions or if subdirectory already exists\n";
        std::cerr << "\n";
        showUsage(applicationName);

        return EXIT_FAILURE;
    }

    if(forceOverwrite)
    {
        std::cout << "Overwriting day: " << newDay << "...\n";
    }
    else
    {
        std::cout << "Starting new day: " << newDay << "...\n";
    }

    const auto solutionPartDirectoriesOpt = createSolutionPartDirectories(newDayPath);
    if(!solutionPartDirectoriesOpt.has_value())
    {
        std::cerr << "Could not create solution part subdirectories\n";
        return EXIT_FAILURE;
    }

    const auto solutionPart1Path = solutionPartDirectoriesOpt.value().first;
    const auto solutionPart2Path = solutionPartDirectoriesOpt.value().second;

    if(!createCMakeLists(newDayPath, true))
    {
        std::cerr << "Could not create CMakeLists.txt for " << newDayPath << "\n";
        return EXIT_FAILURE;
    }

    if(!createCMakeLists(solutionPart1Path, false))
    {
        std::cerr << "Could not create CMakeLists.txt for " << solutionPart1Path << "\n";
        return EXIT_FAILURE;
    }

    if(!createCMakeLists(solutionPart2Path, false))
    {
        std::cerr << "Could not create CMakeLists.txt for " << solutionPart2Path << "\n";
        return EXIT_FAILURE;
    }

    if(!createSourceFiles(newDayPath, true))
    {
        std::cerr << "Could not create source files for " << newDayPath << "\n";
        return EXIT_FAILURE;
    }

    if(!createSourceFiles(solutionPart1Path, false))
    {
        std::cerr << "Could not create source files for " << solutionPart1Path << "\n";
        return EXIT_FAILURE;
    }

    if(!createSourceFiles(solutionPart2Path, false))
    {
        std::cerr << "Could not create source files for " << solutionPart2Path << "\n";
        return EXIT_FAILURE;
    }

    std::cout << "Files created:\n";
    showNewDayContents(newDayPath);
    std::cout << "\n";

    std::cout << "Be sure to add new directory to root solutions CMakeLists.txt and re-run CMake\n";

    return EXIT_SUCCESS;
}